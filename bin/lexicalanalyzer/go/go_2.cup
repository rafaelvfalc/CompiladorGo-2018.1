package lexicalanalyzer.go;

import java_cup.runtime.*;

parser code {:

    public void report_error(String message, Object info) {
        StringBuilder m = new StringBuilder("Error");

        if (info instanceof java_cup.runtime.Symbol) {
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);

            if (s.left  == 0) {
                m.append(" in line "+(s.left - 1));
                if (s.right  == 0)
                    m.append(", column "+(s.right - 1));
            }
        }

        m.append(" : "+message);

        /* Print the contents of the StringBuilder 'm', which contains
           an error message, out on a line. */
        System.err.println(m);
    }

    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        System.exit(1);
    }
:};

// Terminais

terminal BREAK, CASE, CHAN, CONST, CONTINUE, DEFAULT;
terminal DEFER, ELSE, FALLTHROUGH, FOR, FUNC, GO, GOTO;
terminal IF, IMPORT, INTERFACE, MAP, PACKAGE, RANGE, RETURN;
terminal SELECT, STRUCT, SWITCH, TYPE, VAR, BOOL;
terminal STRING, INT, INT8, INT16, INT32, INT64;
terminal UINT, UINT8, UINT16, UINT32, UINT64, UINTPTR;
terminal BYTE, RUNE, FLOAT32, FLOAT64, COMPLEX64;
terminal COMPLEX128, TRUE, FALSE, LPAREN, RPAREN;
terminal LBRACE, RBRACE, LBRACK, RBRACK, SEMICOLON;
terminal COMMA, DOT, COLON, EQUAL, GREATER, LESS;
terminal NOT, EQEQ, LTEQ, GTEQ, NOTEQ, ANDAND, OROR;
terminal PLUSPLUS, MINUSMINUS, PLUS, MINUS, MULT, DIV;
terminal AND, OR, XOR, MOD, LSHIFT, RSHIFT, PLUSEQ;
terminal MINUSEQ, MULTEQ, DIVEQ, ANDEQ, OREQ, XOREQ;
terminal MODEQ, LSHIFTEQ, RSHIFTEQ, ID, NUMERO, COMENTARIO;
terminal a , b , c , d , e , f , A , B , C , D , E , F, x; 
terminal X, l, input_character, escape_character, except; 
terminal STRING_LITERAL, INTEGER_LITERAL, FLOAT_LITERAL;
terminal HEXAL_LITERAL, OCTAL_LITERAL, CHANNEL, DECEQ; 
terminal UNDERSCORE, QUOTE, SUSPOINTS, ANDNOT, ANDNOTEQ;
terminal IMAGINARY_LITERAL, ALL_STRINGS_LITERAL;

// Nao terminais
non terminal compilation_unit, package_clause_aux, identifier, package_name, package_clause, import_clause, import_clause_e;
non terminal import_clause_e_aux, import_clause_aux, import_name, import_name_aux, import_clause_aux_2, import_name_aux_2;
non terminal function_decl, type_declaration, type_declaration_e, type_declaration_e_aux, function_name, signature, parameters;
non terminal result_aux, result, parameters_list, parameters_list_aux, parameter_decl, identifier_list, identifier_list_aux;
non terminal identifier_list_aux_2, sus_points_aux, qualified_ident, type_name, decimal_lit, octal_lit, hex_lit, int_lit;
non terminal array_type, struct_type, pointer_type, function_type, interface_type, slice_type, map_type, channel_type; 
non terminal type_lit, type, float_lit, imaginary_lit, string_lit, basic_lit, field_name, literal_value, expression;
non terminal element, key, keyed_element_aux, keyed_element, literal_value_aux_1, literal_value_aux_2, element_list;
non terminal element_type, literal_type, composite_lit, function_body, block, function_lit, literal, operand_name;
non terminal operand, statements_aux, statements, statement_list, empty_stmt, statement, declaration, labeled_stmt, simple_stmt;
non terminal go_stmt, return_stmt, break_stmt, continue_stmt, goto_stmt, fallthrough_stmt, if_stmt, switch_stmt, select_stmt;
non terminal for_stmt, defer_stmt, expression_stmt, send_stmt, inc_dec_stmt, assignment, short_var_decl, label, inc_dec_stmt_aux;

start with compilation_unit;

compilation_unit ::= empty_stmt;//package_clause_aux import_clause_e_aux  type_declaration_e_aux;

// Identifier

identifier ::= ID;

// Package clause FUNCIONANDO!

package_clause_aux ::= | package_clause;
package_clause ::= PACKAGE package_name;
package_name ::= identifier
		| package_name DOT identifier;
		
// Import clause FUNCIONANDO PARCIALMENTE!

// Observacao: import "fmt.tst" e "fmt/tst" nao estao funcionando VERIFICAR DEPOIS!

import_clause_e_aux ::= | import_clause_e;
import_clause_e ::= import_clause | import_clause import_clause_e;
import_clause ::= IMPORT import_name
                  | IMPORT LPAREN import_name import_name_aux_2 RPAREN;

import_name ::= import_clause_aux import_name_aux;
import_name_aux ::=  QUOTE identifier  QUOTE 
		           | QUOTE import_name DOT identifier QUOTE;    
import_name_aux_2 ::= | import_name import_name_aux_2;                    
import_clause_aux ::= | import_clause_aux_2;
import_clause_aux_2 ::= DOT | UNDERSCORE;

// Type declarations

type_declaration_e_aux ::= | type_declaration_e:t {:RESULT = t;:};
type_declaration_e ::= type_declaration:t {:RESULT = t;:}
			| type_declaration_e type_declaration;
type_declaration ::= function_decl;
		//| method_decl | interface_decl;

// Function Types

signature ::= parameters | result_aux;
result_aux ::= | result;
result ::= ;
parameters ::= LPAREN parameters_list_aux RPAREN;
parameters_list_aux ::= | parameters_list;
parameters_list ::= parameter_decl; //| parameter_decl parameters_list_aux ;
parameter_decl ::= identifier_list_aux_2 sus_points_aux type;
sus_points_aux ::= | SUSPOINTS;

// Function declarations

function_decl ::= FUNC function_name signature LBRACE function_body RBRACE;
function_name ::= identifier;
function_body ::= block;

// Constant declarations

identifier_list ::= identifier | identifier identifier_list_aux;
identifier_list_aux ::= | COMMA identifier_list;
identifier_list_aux_2 ::= | identifier_list;

// Qualified identifier

qualified_ident ::= package_name DOT identifier;

// Types

type ::= type_name | type_lit | LPAREN type RPAREN;
type_name ::= ID | qualified_ident;
type_lit ::= array_type | struct_type | pointer_type | function_type | interface_type | slice_type | map_type | channel_type;

// Operands

operand ::= literal | operand_name | LPAREN expression RPAREN;
literal ::= basic_lit | composite_lit | function_lit;
basic_lit ::= int_lit | float_lit | imaginary_lit | string_lit; // | rune_lit;
operand_name ::= identifier | qualified_ident;

// Composite literals

composite_lit ::= literal_type literal_value;
literal_type ::= struct_type | array_type | LBRACK SUSPOINTS RBRACK element_type | slice_type | map_type | type_name;
literal_value ::= LBRACE literal_value_aux_2 RBRACE;
literal_value_aux_2 ::= | element_list | literal_value_aux_1;
literal_value_aux_1 ::= | COMMA;
keyed_element ::= keyed_element_aux element;
keyed_element_aux ::= | key COLON;
key ::= field_name | expression | literal_value;
field_name ::= identifier; 
element ::= expression | literal_value;

// Function literal

function_lit ::= FUNC signature function_body;

// Integer literals

int_lit ::= decimal_lit | octal_lit | hex_lit;
decimal_lit ::= INTEGER_LITERAL;
octal_lit ::=  OCTAL_LITERAL;
hex_lit ::= HEXAL_LITERAL;

// Float literals
// Obs: Float not working with Exponential and (digit.) floats, verify!!!
float_lit ::= decimal_lit |	 FLOAT_LITERAL;

// Imaginary literals
imaginary_lit ::= float_lit IMAGINARY_LITERAL;

// Rune literals
//TODO

//String literals
// Obs: Matching invalid unicode characters, verify!!!
string_lit ::= ALL_STRINGS_LITERAL;

// Block

block ::= LBRACE statement_list RBRACE;
statement_list ::= statements statements_aux;
statements_aux ::= | statements_aux statements | statements;

// Statements

statement ::= declaration | labeled_stmt | simple_stmt | go_stmt | return_stmt | break_stmt | continue_stmt | goto_stmt | fallthrough_stmt | block | if_stmt | switch_stmt | select_stmt | for_stmt | defer_stmt;

simple_stmt ::= empty_stmt | expression_stmt | send_stmt | inc_dec_stmt | assignment | short_var_decl;

// Empty statements

empty_stmt ::= ;

// Labeled statements

labeled_stmt ::= label COLON statement;
label ::= identifier;

// Expression statements

expression_stmt ::= expression;

// Send statements
// Obs: Has 'Channel' operations, ignore
send_stmt ::= ;

// IncDec statements

inc_dec_stmt ::= expression inc_dec_stmt_aux;
inc_dec_stmt_aux ::= PLUSPLUS | MINUSMINUS;





