package lexicalanalyzer.go;

import java_cup.runtime.*;

parser code {:

    public void report_error(String message, Object info) {
        StringBuilder m = new StringBuilder("Error");

        if (info instanceof java_cup.runtime.Symbol) {
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);

            if (s.left  == 0) {
                m.append(" in line "+(s.left - 1));
                if (s.right  == 0)
                    m.append(", column "+(s.right - 1));
            }
        }

        m.append(" : "+message);

        /* Print the contents of the StringBuilder 'm', which contains
           an error message, out on a line. */
        System.err.println(m);
    }

    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        System.exit(1);
    }
:};

// Terminais

terminal BREAK, CASE, CHAN, CONST, CONTINUE, DEFAULT;
terminal DEFER, ELSE, FALLTHROUGH, FOR, FUNC, GO, GOTO;
terminal IF, IMPORT, INTERFACE, MAP, PACKAGE, RANGE, RETURN;
terminal SELECT, STRUCT, SWITCH, TYPE, VAR, BOOL;
terminal STRING, INT, INT8, INT16, INT32, INT64;
terminal UINT, UINT8, UINT16, UINT32, UINT64, UINTPTR;
terminal BYTE, RUNE, FLOAT32, FLOAT64, COMPLEX64;
terminal COMPLEX128, TRUE, FALSE, LPAREN, RPAREN;
terminal LBRACE, RBRACE, LBRACK, RBRACK, SEMICOLON;
terminal COMMA, DOT, COLON, EQUAL, GREATER, LESS;
terminal NOT, EQEQ, LTEQ, GTEQ, NOTEQ, ANDAND, OROR;
terminal PLUSPLUS, MINUSMINUS, PLUS, MINUS, MULT, DIV;
terminal AND, OR, XOR, MOD, LSHIFT, RSHIFT, PLUSEQ;
terminal MINUSEQ, MULTEQ, DIVEQ, ANDEQ, OREQ, XOREQ;
terminal MODEQ, LSHIFTEQ, RSHIFTEQ, ID, NUMERO, COMENTARIO;
terminal STRING_LITERAL, INTEGER_LITERAL, FLOAT_LITERAL;
terminal HEXAL_LITERAL, OCTAL_LITERAL, CHANNEL, DECEQ; 
terminal UNDERSCORE, QUOTE, SUSPOINTS, ANDNOT, ANDNOTEQ;
terminal IMAGINARY_LITERAL, ALL_STRINGS_LITERAL;

// Nao terminais
non terminal compilation_unit, identifier, int_lit, decimal_lit, octal_lit, hex_lit, float_lit, imaginary_lit;
non terminal string_lit, type, type_name, type_lit, qualified_ident , array_type, struct_type, pointer_type;
non terminal function_type, interface_type, slice_type, map_type, array_length, element_type, expression;
non terminal field_decl_aux_1, field_decl, field_decl_aux_2, field_decl_aux_3, identifier_list, embedded_field;
non terminal tag, embedded_field_aux, base_type, signature, parameters, signature_aux, result, parameters_aux_2;
non terminal parameters_aux_1, parameter_list, parameter_decl, parameter_list_aux_2, parameter_list_aux_1;
non terminal parameter_decl_aux_1, parameter_decl_aux_2, interface_type_aux, method_spec, method_name, key_type;
non terminal interface_type_name, block, statement_list, statement_list_aux, statement, declaration, const_decl;
non terminal type_decl, var_decl, top_level_decl, function_decl, method_decl, const_decl_aux_3, const_decl_aux_2;
non terminal const_decl_aux_1, const_spec, const_spec_aux_2, const_spec_aux_1, expression_list, identifier_list_aux_2;
non terminal identifier_list_aux_1, expression_list_aux_1, expression_list_aux_2, type_decl_aux_2, type_decl_aux_1;
non terminal type_spec, type_decl_aux_3, alias_decl, type_def, var_decl_aux_3, var_decl_aux_2, var_decl_aux_1;
non terminal var_spec, var_spec_aux_3, var_spec_aux_2, var_spec_aux_1, short_var_decl, function_name;
non terminal function_decl_aux, fuction_body, function_body, receiver, method_decl_aux, operand, literal;
non terminal operand_name, basic_lit, composite_lit, function_lit, package_name, literal_type, literal_value;
non terminal literal_value_aux_1, literal_value_aux_2, element_list, element_list_aux_1, element_list_aux_2;
non terminal key, keyed_element, keyed_element_aux_1, keyed_element_aux_2, field_name, element, primary_expr;
non terminal conversion, method_expr, selector, index, slice, type_assertion, arguments, slice_aux_1;
non terminal arguments_aux_1, arguments_aux_2, arguments_aux_3, arguments_aux_4, arguments_aux_5, arguments_aux_6;
non terminal receiver_type, unary_expr, binary_op, rel_op, unary_op, add_op, mul_op, conversion_aux;
non terminal labeled_stmt, simple_stmt, go_stmt, return_stmt, break_stmt, continue_stmt, goto_stmt, fallthrough_stmt;
non terminal if_stmt, switch_stmt, select_stmt, for_stmt, defer_stmt, empty_stmt, expression_stmt, inc_dec_stmt_aux;
non terminal inc_dec_stmt, assignment, label, assign_op, assign_op_aux, if_stmt_aux_1, if_stmt_aux_2, if_stmt_aux_3;
non terminal if_stmt_aux_4, expr_switch_stmt, type_switch_stmt, expr_switch_stmt_aux_1, expr_switch_stmt_aux_2;
non terminal expr_switch_stmt_aux_3, expr_case_clause, expr_switch_case, type_switch_stmt_aux_1, type_switch_guard;
non terminal type_switch_stmt_aux_2, type_case_clause, type_switch_guard_aux_2, type_switch_guard_aux_1;
non terminal type_switch_case, type_list, type_list_aux_1, type_list_aux_2, for_stmt_aux_1, for_stmt_aux_2;
non terminal condition, for_clause, range_clause, for_clause_aux_1, for_clause_aux_2, for_clause_aux_3;
non terminal init_stmt, post_stmt, range_clause_aux_1, range_clause_aux_2, select_stmt_aux, comm_clause;
non terminal comm_case, recv_stmt, recv_stmt_aux_1, recv_stmt_aux_2, recv_expr, return_stmt_aux, break_stmt_aux;
non terminal continue_stmt_aux, package_clause_aux, package_clause, import_clause_e_aux, import_clause_e, import_clause;
non terminal import_name, import_name_aux, import_name_aux_2, import_clause_aux, import_clause_aux_2;

start with compilation_unit;

compilation_unit ::= package_clause_aux import_clause_e_aux;

// Identifier

identifier ::= ID;

// Integer literals

int_lit ::= decimal_lit | octal_lit | hex_lit;
decimal_lit ::= INTEGER_LITERAL;
octal_lit ::=  OCTAL_LITERAL;
hex_lit ::= HEXAL_LITERAL;

// Float literals
// Obs: Float not working with Exponential and (digit.) floats.
float_lit ::= decimal_lit |	 FLOAT_LITERAL;

// Imaginary literals
// Obs: Imaginary getting all 'float_lit' errors.
imaginary_lit ::= float_lit IMAGINARY_LITERAL;

// Rune literals
//TODO
 
 //String literals
// Obs: Matching invalid unicode characters.
string_lit ::= ALL_STRINGS_LITERAL;

// Types 
// TODO TESTE
type ::= type_name | type_lit | LPAREN type RPAREN;
type_name ::= ID | qualified_ident;
type_lit ::= array_type | struct_type | pointer_type | function_type | interface_type | slice_type | map_type;

// Array Types
// TODO TEST
array_type ::= LBRACK array_length RBRACK element_type;
array_length ::= expression;
element_type ::= type;

// Slice Types
// TODO TEST
slice_type ::= LBRACK  RBRACK element_type;

// Struct Types
// TODO TEST
struct_type ::= STRUCT LBRACE field_decl_aux_1 RBRACE;
field_decl ::= field_decl_aux_2 field_decl_aux_3;
field_decl_aux_1 ::= | field_decl_aux_1 field_decl;
field_decl_aux_2 ::= identifier_list type | embedded_field;
field_decl_aux_3 ::= | tag;
embedded_field ::= embedded_field_aux type_name;
embedded_field_aux ::= | MULT;
tag ::= string_lit;

// Pointer Types
// TODO TEST
pointer_type ::= MULT base_type;
base_type ::= type;

// Function Types
// TODO TEST
function_type ::= FUNC signature;
signature ::= parameters signature_aux;
signature_aux ::= | result;
result ::= parameters | type;
parameters ::= LPAREN parameters_aux_2 RPAREN;
parameters_aux_1 ::= | COMMA;
parameters_aux_2 ::= | parameter_list parameters_aux_1;
parameter_list ::= parameter_decl parameter_list_aux_2;
parameter_list_aux_1 ::= COMMA parameter_decl;
parameter_list_aux_2 ::= | parameter_list_aux_1 | parameter_list_aux_1 parameter_list_aux_2;
parameter_decl ::= parameter_decl_aux_1 parameter_decl_aux_2  type;
parameter_decl_aux_1 ::= | identifier_list;
parameter_decl_aux_2 ::= | SUSPOINTS;

// Interface Types
// TODO TEST
interface_type ::= INTERFACE LBRACE interface_type_aux RBRACE;
interface_type_aux ::= | method_spec | method_spec interface_type_aux;
method_spec ::= method_name signature | interface_type_name;
method_name ::= identifier;
interface_type_name ::= type_name;

// Map Types
// TODO TEST
map_type ::= MAP LBRACK key_type RBRACK element_type;
key_type ::= type;

// Blocks
// TODO TEST
block ::= LBRACE statement_list RBRACE;
statement_list ::= statement_list_aux;
statement_list_aux ::= | statement | statement statement_list_aux;

// Declarations and scope
// TODO TEST
declaration ::= const_decl | type_decl | var_decl;
top_level_decl ::= declaration | function_decl | method_decl;

// Constant declarations
// TODO TEST
const_decl ::= CONST const_decl_aux_3;
const_decl_aux_1 ::= | const_spec | const_spec const_decl_aux_1;
const_decl_aux_2 ::= LPAREN const_decl_aux_1 RPAREN;
const_decl_aux_3 ::= const_spec | const_decl_aux_2;
const_spec ::= identifier_list const_spec_aux_2;
const_spec_aux_1 ::= | type;
const_spec_aux_2 ::= | const_spec_aux_1 EQUAL expression_list;
identifier_list ::= identifier identifier_list_aux_2;
identifier_list_aux_1 ::= COMMA identifier;
identifier_list_aux_2 ::= | identifier | identifier_list_aux_1 identifier;
expression_list ::= expression expression_list_aux_2;
expression_list_aux_1 ::= COMMA expression;
expression_list_aux_2 ::= | expression | expression_list_aux_1 expression;

// Type declarations 
// TODO TEST
type_decl ::= TYPE type_decl_aux_3;
type_decl_aux_1 ::= | type_spec | type_decl_aux_1 type_spec;
type_decl_aux_2 ::= LPAREN type_decl_aux_1 RPAREN;
type_decl_aux_3 ::= type_spec | type_decl_aux_2;
type_spec ::= alias_decl | type_def;

	// Alias declarations
	// TODO TEST
alias_decl ::= identifier EQUAL type;

// Type definitions
// TODO TEST
type_def ::= identifier type;

// Variable declarations
// TODO TEST
var_decl ::= VAR var_decl_aux_3;
var_decl_aux_1 ::= | var_spec | var_decl_aux_1 var_spec;
var_decl_aux_2 ::= LPAREN var_decl_aux_1 RPAREN;
var_decl_aux_3 ::= var_spec | var_decl_aux_2;
var_spec ::= identifier_list var_spec_aux_3;
var_spec_aux_1 ::= EQUAL expression_list;
var_spec_aux_2 ::= | var_spec_aux_1;
var_spec_aux_3 ::= type var_spec_aux_2 | var_spec_aux_1;

// Short variable declarations
// TODO TEST
short_var_decl ::= identifier_list DECEQ expression_list;

// Function declarations
// TODO TEST
function_decl ::= FUNC function_name signature function_decl_aux;
function_decl_aux ::= | fuction_body;
function_name ::= identifier;
function_body ::= block;

// Method declarations
// TODO TEST
method_decl ::= FUNC receiver method_name signature method_decl_aux;
method_decl_aux ::= | fuction_body;
receiver ::= parameters;

// Operands
// TODO TEST
operand ::= literal | operand_name | LPAREN expression RPAREN;
literal ::= basic_lit | composite_lit | function_lit;
basic_lit ::= int_lit | float_lit | imaginary_lit | string_lit; // | rune_lit;
operand_name ::= identifier | qualified_ident;

// Qualified Identifiers
// TODO TEST	
qualified_ident ::= package_name DOT identifier;

// Composite Literals
// TODO TEST
composite_lit ::= literal_type literal_value;
literal_type ::= struct_type | array_type | LBRACK SUSPOINTS RBRACK element_type | slice_type | map_type | type_name;
literal_value ::= LBRACE literal_value_aux_2 RBRACE;
literal_value_aux_1 ::= | COMMA;
literal_value_aux_2 ::= | element_list literal_value_aux_1;
element_list ::= keyed_element element_list_aux_2;
element_list_aux_1 ::= COMMA keyed_element;
element_list_aux_2 ::= | keyed_element | keyed_element element_list_aux_1;
keyed_element ::= keyed_element_aux_2 element;
keyed_element_aux_1 ::= key COLON;
keyed_element_aux_2 ::= | keyed_element_aux_1;
key ::= field_name | expression | literal_value;
field_name ::=  identifier;
element ::= expression | literal_value;

// Function Literals
// TODO TEST
function_lit ::= FUNC signature function_body;

// Primary Expressions
// TODO TEST
primary_expr ::= operand | conversion | method_expr | primary_expr selector | primary_expr index | primary_expr slice | primary_expr type_assertion | primary_expr arguments;
selector ::= DOT identifier;
index ::= LBRACK expression RBRACK;
slice ::= LBRACK slice_aux_1 COLON slice_aux_1 RBRACK | LBRACK slice_aux_1 COLON expression COLON expression RBRACE;
slice_aux_1 ::= | expression;
type_assertion ::= DOT LPAREN type RPAREN;
arguments ::= LPAREN arguments_aux_6 RPAREN;
arguments_aux_1 ::= | COMMA expression_list;
arguments_aux_2 ::= expression_list | type arguments_aux_1;
arguments_aux_3 ::= | SUSPOINTS;
arguments_aux_4 ::= | COMMA;
arguments_aux_5 ::= arguments_aux_2 arguments_aux_3 arguments_aux_4;
arguments_aux_6 ::= | arguments_aux_5;

// Method Expressions
// TODO TEST
method_expr ::= receiver_type DOT method_name;
receiver_type ::= type;

// Operators
// TODO TEST
expression ::= unary_expr | expression binary_op expression;
unary_expr ::= primary_expr | unary_op unary_expr;

binary_op ::= OROR | ANDAND | rel_op | add_op | mul_op;
rel_op ::= EQEQ | NOTEQ | LESS | LTEQ | GREATER | GTEQ;
add_op ::= PLUS | MINUS | OR | XOR;
mul_op ::= MULT | DIV | MOD | LSHIFT | RSHIFT | AND | ANDNOT;

unary_op ::= PLUS | MINUS | NOT | XOR | MULT | AND;

// Conversions
// TODO TEST
conversion ::= type LPAREN expression conversion_aux RPAREN;
conversion_aux ::= | COMMA;

// Statements
// TODO TEST
statement ::= declaration | labeled_stmt | simple_stmt | go_stmt | return_stmt | break_stmt | continue_stmt | goto_stmt | fallthrough_stmt | block | if_stmt | switch_stmt | select_stmt | for_stmt | defer_stmt;

simple_stmt ::= empty_stmt | expression_stmt | inc_dec_stmt | assignment | short_var_decl;

// Empty statements
// TODO TEST
empty_stmt ::= ;

// Labeled statements
// TODO TEST
labeled_stmt ::= label COLON statement;
label ::= identifier;

// Expression statements
// TODO TEST
expression_stmt ::= expression;
	
// IncDec statements
// TODO TEST
inc_dec_stmt ::= expression inc_dec_stmt_aux;
inc_dec_stmt_aux ::= PLUSPLUS | MINUSMINUS;

// Assignments
// TODO TEST
assignment ::= expression_list assign_op expression_list;

assign_op ::= assign_op_aux EQUAL;
assign_op_aux ::= | add_op | mul_op;

// If statements
// TODO TEST
if_stmt ::= IF if_stmt_aux_1 expression block if_stmt_aux_4;
if_stmt_aux_1 ::= | simple_stmt;
if_stmt_aux_2 ::= if_stmt | block;
if_stmt_aux_3 ::= ELSE if_stmt_aux_2;
if_stmt_aux_4 ::= | if_stmt_aux_3 ;

// Switch statements
// TODO TEST
switch_stmt ::= expr_switch_stmt | type_switch_stmt;

	// Expression switches
	// TODO TEST
expr_switch_stmt ::= SWITCH expr_switch_stmt_aux_1 expr_switch_stmt_aux_2 LBRACE expr_switch_stmt_aux_3 RBRACE;
expr_switch_stmt_aux_1 ::= | simple_stmt;
expr_switch_stmt_aux_2 ::= | expression;
expr_switch_stmt_aux_3 ::= | expr_case_clause | expr_switch_stmt_aux_3 expr_case_clause;
expr_case_clause ::= expr_switch_case COLON statement_list;
expr_switch_case ::= CASE expression_list | DEFAULT;

	// Type switches
	// TODO TEST
type_switch_stmt  ::= SWITCH type_switch_stmt_aux_1 type_switch_guard LBRACE type_switch_stmt_aux_2 RBRACE;
type_switch_stmt_aux_1 ::= | simple_stmt;
type_switch_stmt_aux_2 ::= | type_case_clause | type_switch_stmt_aux_2 type_case_clause;
type_switch_guard ::= type_switch_guard_aux_2 primary_expr DOT LPAREN TYPE RPAREN;
type_switch_guard_aux_1 ::= identifier DECEQ;
type_switch_guard_aux_2 ::= | type_switch_guard_aux_1;
type_case_clause ::= type_switch_case COLON statement_list;
type_switch_case ::= CASE type_list | DEFAULT;
type_list ::= type type_list_aux_2;
type_list_aux_1 ::= COMMA type;
type_list_aux_2 ::= | type | type_list_aux_1 type_list_aux_2;

// For stataments
// TODO TEST
for_stmt ::= FOR for_stmt_aux_1  block;
for_stmt_aux_1 ::= condition | for_clause | range_clause;
for_stmt_aux_2 ::= | for_stmt_aux_1;
condition ::= expression;

	// For statements with for clause
	// TODO TEST
for_clause ::= for_clause_aux_1 SEMICOLON for_clause_aux_2 SEMICOLON for_clause_aux_3;
for_clause_aux_1 ::= | init_stmt;
for_clause_aux_2 ::= | condition;
for_clause_aux_3 ::= | post_stmt;
init_stmt ::= simple_stmt;
post_stmt ::= simple_stmt;

	// For statements with range clause
	// TODO TEST
range_clause ::= range_clause_aux_2 RANGE expression;
range_clause_aux_1 ::= expression_list EQUAL | identifier_list DECEQ;
range_clause_aux_2 ::= | range_clause_aux_1;

// Go statements
// TODO TEST
go_stmt ::= GO expression;

// Select statements
// TODO TEST
select_stmt ::= SELECT LBRACE select_stmt_aux RBRACE;
select_stmt_aux ::= | comm_clause | comm_clause select_stmt_aux;
comm_clause ::= comm_case COLON statement_list;
comm_case ::= CASE recv_stmt | DEFAULT;
recv_stmt ::= recv_stmt_aux_2 recv_expr;
recv_stmt_aux_1 ::= expression_list EQUAL | identifier_list DECEQ;
recv_stmt_aux_2 ::= | recv_stmt_aux_1;
recv_expr ::= expression;

// Return statements
// TODO TEST
return_stmt ::= RETURN return_stmt_aux ;
return_stmt_aux ::= | expression_list;

// Break statements
// TODO TEST
break_stmt ::= BREAK break_stmt_aux;
break_stmt_aux ::= | label;

// Continue statements
// TODO TEST
continue_stmt ::= CONTINUE continue_stmt_aux;
continue_stmt_aux ::= | label;

// Goto statements
// TODO TEST
goto_stmt ::= GOTO label;

// Fallthrough statements
// TODO TEST
fallthrough_stmt ::= FALLTHROUGH;

// Defer statements
// TODO TEST
defer_stmt ::= DEFER expression;

// Package clause

package_clause_aux ::= | package_clause;
package_clause ::= PACKAGE package_name;
package_name ::= identifier | package_name DOT identifier;

// Import clause
// Obs: import "fmt.tst" e "fmt/tst" nao estao funcionando.

import_clause_e_aux ::= | import_clause_e;
import_clause_e ::= import_clause | import_clause import_clause_e;
import_clause ::= IMPORT import_name
                  | IMPORT LPAREN import_name import_name_aux_2 RPAREN;

import_name ::= import_clause_aux import_name_aux;
import_name_aux ::=  QUOTE identifier  QUOTE 
		           | QUOTE import_name DOT identifier QUOTE;    
import_name_aux_2 ::= | import_name import_name_aux_2;                    
import_clause_aux ::= | import_clause_aux_2;
import_clause_aux_2 ::= DOT | UNDERSCORE;



