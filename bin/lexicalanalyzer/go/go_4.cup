package lexicalanalyzer.go;

import java_cup.runtime.*;

parser code {:

    public void report_error(String message, Object info) {
        StringBuilder m = new StringBuilder("Error");

        if (info instanceof java_cup.runtime.Symbol) {
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
			
            m.append(" in line "+(s.left + 1));
            m.append(", column "+(s.right + 1));
        }

        m.append(" : "+message);

        /* Print the contents of the StringBuilder 'm', which contains
           an error message, out on a line. */
        System.err.println(m);
    }

    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        System.exit(1);
    }
:};

// Terminais

terminal BREAK, CASE, CHAN, CONST, CONTINUE, DEFAULT;
terminal DEFER, ELSE, FALLTHROUGH, FOR, FUNC, GO, GOTO;
terminal IF, IMPORT, INTERFACE, MAP, PACKAGE, RANGE, RETURN;
terminal SELECT, STRUCT, SWITCH, TYPE, VAR, BOOL;
terminal STRING, INT, INT8, INT16, INT32, INT64;
terminal UINT, UINT8, UINT16, UINT32, UINT64, UINTPTR;
terminal BYTE, RUNE, FLOAT32, FLOAT64, COMPLEX64;
terminal COMPLEX128, TRUE, FALSE, LPAREN, RPAREN;
terminal LBRACE, RBRACE, LBRACK, RBRACK, SEMICOLON;
terminal COMMA, DOT, COLON, EQUAL, GREATER, LESS;
terminal NOT, EQEQ, LTEQ, GTEQ, NOTEQ, ANDAND, OROR;
terminal PLUSPLUS, MINUSMINUS, PLUS, MINUS, MULT, DIV;
terminal AND, OR, XOR, MOD, LSHIFT, RSHIFT, PLUSEQ;
terminal MINUSEQ, MULTEQ, DIVEQ, ANDEQ, OREQ, XOREQ;
terminal MODEQ, LSHIFTEQ, RSHIFTEQ, ID, NUMERO, COMENTARIO;
terminal STRING_LITERAL, INTEGER_LITERAL, FLOAT_LITERAL;
terminal HEXAL_LITERAL, OCTAL_LITERAL, CHANNEL, DECEQ; 
terminal UNDERSCORE, QUOTE, SUSPOINTS, ANDNOT, ANDNOTEQ;
terminal IMAGINARY_LITERAL, ALL_STRINGS_LITERAL;


// Nao terminais

non terminal compilation_unit, package_clause_aux, package_clause, package_name, identifier, import_decl, import_decl_aux;
non terminal import_decl_e, import_decl_e_aux, import_decl_1, import_decl_1_aux, identifier_e, import_decl_e_1, import_decl_e_aux_1;
non terminal function_clause, function_name, parameters, block, function_clause_e, function_clause_aux, types, signature, parameters_aux;
non terminal result, variable_name, parameters_aux_1, types_e, assign_op, assignment, assignment_aux_e, assignment_aux_e_1;
non terminal assignment_aux, left_side_assignment, array_indexed, index, seq_variables, seq_array_indexed, optional_var;
non terminal optional_types, right_side_assignment, seq_variables_1, seq_integers_literal, optional_const, expression;
non terminal boolean_op, boolean_expression, if_statement, if_statement_aux, if_statement_aux_e, statements, optional_else_if;
non terminal optional_else, optional_section, optional_else_if_aux, for_statement_single, for_statement_single_aux;
non terminal for_statement_for_clause, init_statement, condition, post_statement, indec_op, indec_statement, for_statement_for_clause_aux;
non terminal for_statement_for_clause_aux_e, for_statement_single_aux_e, init_statement_aux, indec_statement_aux;
non terminal boolean_expression_aux, for_statement_with_range, for_statement_with_range_aux, for_statement_with_range_aux_e;
non terminal right_side_range, switch_statement, switch_statement_aux, switch_statement_aux_e, switch_block, left_side_switch;
non terminal optional_default, case, case_aux, case_aux_e, switch_block_1, case_block, type_statement, array_types_aux_e;
non terminal type_statement_aux, type_statement_aux_e, array_types, array_types_aux, array_types_1, array_types_2;
non terminal optional_block, struct_statement, struct_statement_aux, struct_statement_aux_e, struct_variables;
non terminal interface_statement, interface_statement_aux, interface_statement_aux_e, map_statement, map_statement_aux, map_statement_aux_e;
non terminal right_side_map, go_statement, go_statement_aux, go_statement_aux_e, go_to_statement, go_to_statement_aux;
non terminal go_to_statement_aux_e, relational_expression, relational_expression_aux, relational_op, boolean_options;
non terminal bool_rel_expressions;

compilation_unit ::= package_clause_aux:p import_decl_e_aux:i function_clause_aux
                                {:if(p != null && i != null){
                                     System.out.println("PACKAGE RECONIZED: "+ p + "   IMPORT RECONIZED: "+i);
                                }else if(p== null &&  i != null){
                                     System.out.println("IMPORT RECONIZED: "+ i) ;
                                }else if(p != null &&  i == null){
                                     System.out.println("PACKAGE RECONIZED: "+ p );
                               };:};

// Identifier

identifier ::= ID;

// Package clause

package_clause_aux ::= package_clause | error {:System.err.println("Package Error");System.exit(1);:};
package_clause ::= PACKAGE package_name;
package_name ::= identifier;

// Import clause

import_decl_e_aux ::= | import_decl_e_aux_1  | error {:System.err.println("Import Error");System.exit(1);:};
import_decl_e_aux_1 ::= import_decl_e | import_decl_e_1 | import_decl_e import_decl_e_1 | import_decl_e_1 import_decl_e;
import_decl_e ::= import_decl | import_decl_e import_decl;
import_decl_e_1 ::= import_decl_1 | import_decl_e_1 import_decl_1;
import_decl ::= IMPORT import_decl_aux;
import_decl_aux ::= ALL_STRINGS_LITERAL | package_name ALL_STRINGS_LITERAL | DOT ALL_STRINGS_LITERAL | UNDERSCORE ALL_STRINGS_LITERAL;
import_decl_1 ::= IMPORT LPAREN import_decl_1_aux RPAREN;
import_decl_1_aux ::= | identifier_e;
identifier_e ::= ALL_STRINGS_LITERAL | identifier_e ALL_STRINGS_LITERAL;

// Function clause

function_clause_aux ::=  | function_clause_e;
function_clause_e ::= function_clause | function_clause_e function_clause;
function_clause ::= FUNC function_name signature block;
function_name ::= identifier;
signature ::= parameters result;
result ::= | types | LPAREN types_e RPAREN;
types_e ::= types | identifier types | types_e COMMA types | types_e COMMA identifier types;
parameters ::= LPAREN parameters_aux_1 RPAREN;
parameters_aux_1 ::= parameters_aux | parameters_aux_1 COMMA parameters_aux;
parameters_aux ::= | variable_name | variable_name types | variable_name SUSPOINTS types;
variable_name ::= identifier;

// Block

block ::= LBRACE statements RBRACE;

statements ::= | assignment_aux_e_1 | if_statement_aux_e | for_statement_single_aux_e | for_statement_for_clause_aux_e | for_statement_with_range_aux_e | switch_statement_aux_e | type_statement_aux_e | array_types_aux_e | struct_statement_aux_e | interface_statement_aux_e | map_statement_aux_e |  go_statement_aux_e | go_to_statement_aux_e;

assignment_aux_e_1 ::= assignment_aux_e;
assignment_aux_e ::= assignment_aux | assignment_aux_e assignment_aux;

if_statement_aux_e ::= if_statement_aux;
if_statement_aux ::= if_statement | if_statement_aux if_statement;

for_statement_for_clause_aux_e ::= for_statement_for_clause_aux;
for_statement_for_clause_aux ::= for_statement_for_clause | for_statement_for_clause_aux for_statement_for_clause;

for_statement_with_range_aux_e ::= for_statement_with_range_aux;
for_statement_with_range_aux ::= for_statement_with_range | for_statement_with_range_aux for_statement_with_range;

for_statement_single_aux_e ::= for_statement_single_aux;
for_statement_single_aux ::= for_statement_single | for_statement_single_aux for_statement_single;

switch_statement_aux_e ::= switch_statement_aux;
switch_statement_aux ::= switch_statement | switch_statement_aux switch_statement;

type_statement_aux_e ::= type_statement_aux;
type_statement_aux ::= type_statement | type_statement_aux type_statement;

array_types_aux_e ::= array_types_aux;
array_types_aux ::= array_types | array_types_aux array_types;

struct_statement_aux_e ::= struct_statement_aux;
struct_statement_aux ::= struct_statement | struct_statement_aux struct_statement;

interface_statement_aux_e ::= interface_statement_aux;
interface_statement_aux ::= interface_statement | interface_statement_aux interface_statement;

map_statement_aux_e ::= map_statement_aux;
map_statement_aux ::= map_statement | map_statement_aux map_statement;

go_statement_aux_e ::= go_statement_aux;
go_statement_aux ::= go_statement | go_statement_aux go_statement;

go_to_statement_aux_e ::= go_to_statement_aux;
go_to_statement_aux ::= go_to_statement | go_to_statement_aux go_to_statement;

// Types

types ::= BOOL | STRING | INT | INT8 | INT16 | INT32 | INT64 | UINT | UINT8 | UINT16 | UINT32 | UINT64 | UINTPTR | BYTE | RUNE | FLOAT32 | FLOAT64 | COMPLEX64 | COMPLEX128 | INTERFACE LBRACE RBRACE | identifier | LBRACK RBRACK types | MULT types | STRUCT;

// Assignment

assignment_aux ::= assignment;
assignment ::= optional_var optional_const left_side_assignment assign_op right_side_assignment;
assign_op ::= EQUAL | PLUSEQ | MINUSEQ | MULTEQ | DIVEQ | ANDEQ | OREQ | XOREQ | MODEQ | LSHIFTEQ | RSHIFTEQ | ANDNOTEQ | DECEQ;
left_side_assignment ::= MULT variable_name optional_types | seq_array_indexed optional_types  | LPAREN variable_name RPAREN optional_types | IMAGINARY_LITERAL optional_types | seq_variables | UNDERSCORE;
seq_variables ::= variable_name optional_types | seq_variables COMMA variable_name;
optional_var ::= | VAR;
optional_const ::= | CONST;
optional_types ::= | types;
// ADD EXPRESSION TO RULE BELLOW
right_side_assignment ::= seq_integers_literal | seq_variables_1  | ALL_STRINGS_LITERAL | seq_array_indexed | FALSE | TRUE;
seq_integers_literal ::= INTEGER_LITERAL | seq_integers_literal COMMA INTEGER_LITERAL;
seq_variables_1 ::= variable_name | seq_variables_1 COMMA variable_name;

// Array
// ADD expression INSTEAD OF INTEGER_LITERAL
array_types ::= array_types_2 types optional_block;
array_types_2 ::= array_types_1 | array_types_2 array_types_1;
array_types_1 ::= LBRACK INTEGER_LITERAL RBRACK;
optional_block ::= | LBRACE seq_variables RBRACE;

seq_array_indexed ::= array_indexed | seq_array_indexed COMMA array_indexed;
array_indexed ::= variable_name LBRACK index RBRACK;
// ADD EXPRESSION TO RULE BELLOW
index ::= INTEGER_LITERAL | variable_name | IMAGINARY_LITERAL;

// Expression
// TODO
expression ::= variable_name | INTEGER_LITERAL | FLOAT_LITERAL;

// Boolean expression
// TODO

boolean_options ::= TRUE | FALSE | variable_name;

boolean_expression ::= boolean_expression_aux boolean_op boolean_expression_aux | boolean_expression_aux;

boolean_expression_aux ::= boolean_options boolean_op boolean_options | 
						   NOT boolean_options |
						   LPAREN boolean_options boolean_op boolean_options RPAREN |
						   LPAREN NOT boolean_options RPAREN; 
boolean_op ::= ANDAND | OROR | XOR | ANDNOT;

bool_rel_expressions ::= boolean_expression | relational_expression;

// Relational expression
// TODO
relational_expression ::= relational_expression_aux relational_op relational_expression_aux;
relational_expression_aux ::= expression | IMAGINARY_LITERAL;
relational_op ::= NOTEQ | LESS | LTEQ | GREATER | GTEQ | EQEQ | EQUAL;

// InDec statements

indec_statement ::=  indec_statement_aux indec_op;
indec_statement_aux ::= expression | IMAGINARY_LITERAL;
indec_op ::= PLUSPLUS | MINUSMINUS;

// IF Statement

if_statement ::= IF bool_rel_expressions block optional_section;
optional_section ::= | optional_else_if_aux | optional_else_if_aux optional_else | optional_else;
optional_else_if_aux ::= optional_else_if | optional_else_if_aux optional_else_if;
optional_else_if ::= ELSE IF bool_rel_expressions block;
optional_else ::= ELSE block;

// FOR Statement

// FOR with single condiiton

for_statement_single ::= FOR bool_rel_expressions block;

// FOR with for clause

for_statement_for_clause ::= FOR init_statement SEMICOLON condition SEMICOLON post_statement block;
init_statement ::=  | left_side_assignment init_statement_aux right_side_assignment;
init_statement_aux ::=  PLUSEQ | MINUSEQ | MULTEQ | DIVEQ | ANDEQ | OREQ | XOREQ | MODEQ | LSHIFTEQ | RSHIFTEQ | ANDNOTEQ | DECEQ;
condition ::= | bool_rel_expressions;
post_statement ::= | indec_statement;

// FOR with range

for_statement_with_range ::= FOR left_side_assignment DECEQ RANGE right_side_range block;
right_side_range ::= variable_name | UNDERSCORE | IMAGINARY_LITERAL | ALL_STRINGS_LITERAL;

// SWITCHES statements

switch_statement ::= SWITCH left_side_switch switch_block;
switch_block ::= LBRACE switch_block_1 RBRACE;
// Add function to rule bellow
left_side_switch ::= | UNDERSCORE | IMAGINARY_LITERAL | ALL_STRINGS_LITERAL | INTEGER_LITERAL | seq_array_indexed | seq_variables; 
case ::= CASE left_side_switch COLON case_block;
case_aux_e ::= case_aux;
case_aux ::= case | case_aux case;
optional_default ::= DEFAULT COLON;
switch_block_1 ::= | case_aux_e optional_default;
case_block ::= statements;

// Types
//TODO
type_statement ::= TYPE variable_name types;

// Struct

struct_statement ::= STRUCT LBRACE struct_variables RBRACE;
struct_variables ::= | left_side_assignment;

// Interface

interface_statement ::= INTERFACE block;

// Map

map_statement ::= MAP LBRACK types RBRACK right_side_map;
right_side_map ::= | struct_statement | interface_statement;

// Selectors

// AMBIGUIDADE

// Methods

// AMBIGUIDADE

// Conversions

// AMBIGUIDADE

// Go

go_statement ::= GO expression;

// GOSTO

go_to_statement ::= GOTO identifier;

// OBSERVATIONS:
// Add float points to all rules
// Finish Statements
// Finish expressions

